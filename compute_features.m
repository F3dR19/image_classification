function [ reduced_images_train, reduced_images_test ] = compute_features( images_train, images_test, labels_test, method, k, j )
% Recovers main features using various methods, and projects images on this
% newly found subspace
%
% Input:
%		images_train = set of train images (each of them is a column vector)
%		images_test = set of test images (each of them is a column vector)
%		method = specifies the method used
%		k = number of features to recover
%		j = number of largest features to discard (default = 0)
% 
% Output:
%		reduced_images_train = projected train images		
%		reduced_images_test = projected test images		
%		

% default value for j
if( isempty(j) )
	j=0;
end

% PCA		
if ( strcmp(method, 'PCA') )
    % create covariance matrix
    sigma = images_train * images_train';

    % extract the k largest eigenvalues and the corresponding eigenvectors
    [ eigvectors, ~ ] = eigs( sigma, k+j );

		% remove first few
    eigvectors = eigvectors(:,(1:k)+j);
    
		% project images on the subspace generated by the eigenvectors
    reduced_images_train = eigvectors' * images_train;
    reduced_images_test = eigvectors' * images_test;
    
% PCA with scaling		
elseif ( strcmp(method, 'PCAs') )
    % create covariance matrix
    sigma = images_train * images_train';
    
    % extract the k largest eigenvalues and the corresponding eigenvectors
    [ eigvectors, eigvalues ] = eigs( sigma, k+j );
    
    % remove first few
    eigvectors_rem = eigvectors(:,(1:k)+j);
    eigvalues_rem = eigvalues(:,(1:k)+j);
    
    reduced_images_train = eigvalues_rem.^(-1/2) * eigvectors_rem' * images_train;
    reduced_images_test = eigvalues_rem.^(-1/2) * eigvectors_rem' * images_test;

		
		
% LDA
elseif ( strcmp(method, 'LDA') )
	% first perform PCA	
	% create covariance matrix
  sigma = images_train * images_train';
    
	% extract the k largest eigenvalues and the corresponding eigenvectors
	[ eigvectors, ~ ] = eigs( sigma, 2*k );
  
	reduced_images_train = eigvectors' * images_train;
	reduced_images_test = eigvectors' * images_test;

	
	% now do the actual LDA on the reduced images
	% figure out which images correspond to which digit	
	class_indeces = repmat( labels_test, [1,10] ) == 0:1:9;
	% compute class sizes (ie, how many images of digits there are, per digit)
	class_sizes = sum( class_indeces, 1 );
	
	means = zeros( size( reduced_images_train, 1 ), 10 );
	intra_class_sigma = zeros( size( reduced_images_train, 1 ) ); 
	
	for i = 1:10
		% populate classes with corresponding images
		class = reduced_images_train( :, find( class_indeces( :, i )' ) );
		means( :, i ) = mean( class, 2 );
		% we want them to have zero mean
		class = class - means( :, i );
		% evaluate variance within classes
		intra_class_sigma = intra_class_sigma + class * class';
	end
	
	inter_class_sigma = ( means .* repmat( class_sizes, [ size(means, 1), 1 ]) ) * means';
		
	[ eigvectors, ~ ] = eigs( inter_class_sigma, intra_class_sigma, k );
	
	reduced_images_train = real(eigvectors)' * reduced_images_train;
	reduced_images_test = real(eigvectors)' * reduced_images_test;
	
	
	
	
		
elseif( strcmp( method, 'intensity') )
    reduced_images_train = images_train;
    reduced_images_test = images_test;
else
	
	error('compute_features:invalidMethod', 'Specified method not recognised / not supported. Abort');

end

end