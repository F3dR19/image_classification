function [ reduced_images_train, reduced_images_test ] = compute_features( images_train, images_test, method, k, j )
% Recovers main features using various methods, and projects images on this
% newly found subspace
%
% Input:
%		images_train = set of train images (each of them is a column vector)
%		images_test = set of test images (each of them is a column vector)
%		method = specifies the method used
%		k = number of features to recover
%		j = number of largest features to discard (default = 0)
% 
% Output:
%		reduced_images_train = projected train images		
%		reduced_images_test = projected test images		
%		

% default value for j
if( isempty(j) )
	j=0;
end


% eigenvector decomposition		
if (method==2)
    % create covariance matrix
    sigma = images_train * images_train';

    % extract the k largest eigenvalues and the corresponding eigenvectors
    [ eigvectors, ~ ] = eigs( sigma, k+j );

		% remove first few
    eigvectors = eigvectors(:,(1:k)+j);
    
		% project images on the subspace generated by the eigenvectors
    reduced_images_train = eigvectors' * images_train;
    reduced_images_test = eigvectors' * images_test;
    
% eigenvector decomposition with scaling		
elseif (method==3)
    % create covariance matrix
    sigma = images_train * images_train';
    
    % extract the k largest eigenvalues and the corresponding eigenvectors
    [ eigvectors, eigvalues ] = eigs( sigma, k+j );
    
    % remove first few
    eigvectors = eigvectors(:,(1:k)+j);
    eigvalues = eigvalues((1:k)+j,(1:k)+j);

		% project images on the subspace generated by the eigenvectors,
		% appropriately rescaling them by the eigenvalues
    reduced_images_train = eigvalues.^(-1/2) * eigvectors' * images_train;
    reduced_images_test = eigvalues.^(-1/2) * eigvectors' * images_test;

% no projection is made, and whole image is kept
else	
    reduced_images_train = images_train;
    reduced_images_test = images_test;
end

end