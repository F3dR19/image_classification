function [ reduced_images_train, reduced_images_test ] = compute_features( images_train, images_test, labels_train, method, k, j )
% Recovers main features using various methods, and projects images on this
% newly found subspace
%
% Input:
%		images_train = set of train images (each of them is a column vector)
%		images_test = set of test images (each of them is a column vector)
%       labels_train = labels (digits shown) of train images in a column vector
%		method = specifies the method used
%		k = number of features to recover
%		j = number of largest features to discard (default = 0)
% 
% Output:
%		reduced_images_train = projected train images		
%		reduced_images_test = projected test images		
%		

% default value for j
if( isempty(j) )
	j=0;
end

% check on number of eigenvectors (shouldn't be larger than number of images available)
if( k + j >= size( images_train,1 ) )
	error('compute_features:invalidParameter', 'Dimension of subspace of projection larger than image space. Abort');
end

if( j >= k )
	error('compute_features:invalidParameter', 'Discarding more eigenvectors than the ones we keep. Abort');
end


% PCA		
if ( strcmp(method, 'PCA') )
    % error check
    if ( size(images_train,2) < size(images_train,1) )
        error('compute_Features:sampleSizeError',strcat('Sample size must be >', num2str(size(images_train,1)), '.'))
    end
    
    % create covariance matrix
    sigma = images_train * images_train';

    % extract the k largest eigenvalues and the corresponding eigenvectors
    [ eigvectors, ~ ] = eigs( sigma, k+j );

		% remove first few
    eigvectors = eigvectors(:,(1:k)+j);
    
		% project images on the subspace generated by the eigenvectors
    reduced_images_train = eigvectors' * images_train;
    reduced_images_test = eigvectors' * images_test;
    
% PCA with removal of vectors and scaling		
elseif ( strcmp(method, 'PCAs') )
    % error checks
    if ( size(images_train,2) < size(images_train,1) )
        error('compute_features:sampleSizeError',strcat('Sample size must be >', num2str(size(images_train,1)), '.'))
    end
    
    if (j>k-1)
        error('compute_features:noRemoveError','no_remove must be an integer smaller than no_vectors.')
    end
    
    % create covariance matrix
    sigma = images_train * images_train';
    
    % extract the k largest eigenvalues and the corresponding eigenvectors
    [ eigvectors, eigvalues ] = eigs( sigma, k+j );
    
    % remove first few
    eigvectors_rem = eigvectors(:,(1:k)+j);
    eigvalues_rem = eigvalues(:,(1:k)+j);
    
    reduced_images_train = eigvalues_rem.^(-1/2) * eigvectors_rem' * images_train;
    reduced_images_test = eigvalues_rem.^(-1/2) * eigvectors_rem' * images_test;

% intensity		
elseif( strcmp( method, 'intensity') )
    reduced_images_train = images_train;
    reduced_images_test = images_test;
    
% LDA
elseif ( strcmp(method, 'LDA') )
	% first perform PCA	
	% create covariance matrix
  sigma = images_train * images_train';
    
	% extract the k largest eigenvalues and the corresponding eigenvectors
	[ eigvectors, ~ ] = eigs( sigma, floor(size( sigma, 1 )/2 ) );
  
	reduced_images_train = eigvectors' * images_train;
	reduced_images_test = eigvectors' * images_test;

	
	% now do the actual LDA on the reduced images
	% figure out which images correspond to which digit	
	class_indices = repmat( labels_train, [1,10] ) == 0:1:9;
	% compute class sizes (ie, how many images of digits there are, per digit)
	class_sizes = sum( class_indices, 1 );
	
	means = zeros( size( reduced_images_train, 1 ), 10 );
	intra_class_sigma = zeros( size( reduced_images_train, 1 ) ); 
	
	for i = 1:10
		% populate classes with corresponding images
		class = reduced_images_train( :, class_indeces( :, i )' );

		means( :, i ) = mean( class, 2 );
		% we want them to have zero mean
		class = class - means( :, i );
		% evaluate variance within classes
		intra_class_sigma = intra_class_sigma + class * class';
	end
	
	% evaluate variance between classes	
	inter_class_sigma = ( means .* repmat( class_sizes, [ size(means, 1), 1 ]) ) * means';
	
	% compute separation hyperplanes 
	[ eigvectors, ~ ] = eigs( inter_class_sigma, intra_class_sigma, k );
	
	% project on them
	reduced_images_train = real(eigvectors)' * reduced_images_train;
	reduced_images_test = real(eigvectors)' * reduced_images_test;
	
else
	
	error('compute_features:invalidMethod', 'Specified method not recognised / not supported. Abort');

end

end