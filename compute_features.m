function [ reduced_images_train, reduced_images_test ] = compute_features( images_train, images_test, labels_test, method, k, j )
% Recovers main features using various methods, and projects images on this
% newly found subspace
%
% Input:
%		images_train = set of train images (each of them is a column vector)
%		images_test = set of test images (each of them is a column vector)
%		method = specifies the method used
%		k = number of features to recover
%		j = number of largest features to discard (default = 0)
% 
% Output:
%		reduced_images_train = projected train images		
%		reduced_images_test = projected test images		
%		

% default value for j
if( isempty(j) )
	j=0;
end


% PCA		
if ( strcmp(method, 'PCA') )
    % create covariance matrix
    sigma = images_train * images_train';

    % extract the k largest eigenvalues and the corresponding eigenvectors
    [ eigvectors, ~ ] = eigs( sigma, k+j );

		% remove first few
    eigvectors = eigvectors(:,(1:k)+j);
    
		% project images on the subspace generated by the eigenvectors
    reduced_images_train = eigvectors' * images_train;
    reduced_images_test = eigvectors' * images_test;
    
% PCA with scaling		
elseif ( strcmp(method, 'PCAs') )
    % create covariance matrix
    sigma = images_train * images_train';
    
    % extract the k largest eigenvalues and the corresponding eigenvectors
    [ eigvectors, eigvalues ] = eigs( sigma, k+j );
    
    % remove first few
    eigvectors_rem = eigvectors(:,(1:k)+j);
    eigvalues_rem = eigvalues((1:k)+j,(1:k)+j);
    %eigvalues_rem = eigvalues; eigvectors_rem = eigvectors;
    
    %reduced_images_train = eigvalues_rem.^(-1/2) * eigvectors_rem' * images_train;
    %reduced_images_test = eigvalues_rem.^(-1/2) * eigvectors_rem' * images_test;

    reduced_images_train = eigvectors_rem' * images_train;
    reduced_images_test = eigvectors_rem' * images_test;
		
elseif( strcmp( method, 'intensity') )
    reduced_images_train = images_train;
    reduced_images_test = images_test;
    
% LDA
elseif ( strcmp(method, 'LDA') )
	% figure out which images correspond to which digit	
	class_indeces = repmat( labels_test, [1,10] ) == 0:1:9;
	% compute class sizes (ie, how many images of digits there are, per digit)
	class_sizes = sum( class_indeces, 1 );
	
	classes = cell(1,10);
	intra_class_sigma = zeros( size( images_test,1 ) ); 
	for i = 1:10
		% populate classes with corresponding images
		classes{i} = images_train( :, find( class_indeces( :, i )' ) );
		% we want them to have zero mean
		classes{i} = classes{i} - mean( classes{i},2 );
		% evaluate variance within classes
		intra_class_sigma = intra_class_sigma + classes{i} * classes{i}';
	end
	
else
	
	error('compute_features:invalidMethod', 'Specified method not recognised / not supported. Abort');

end

end